# Unnamed Messaging API

The messaging API allows you to integrate one-to-one and one-to-many group
messaging into your application with little development effort. It also
gives email-based commenting (like Facebook Comments) for free.

## Accessing the API

The base API adheres to REST principles and accepts and returns JSON.
Most of the messaging functionality can also be accessed by including
a JavaScript snippet on any page.

## Mapping User Accounts

The API has no knowledge of your users nor does it need to. However, to
enable sending comment notifications via email and to allow replies, you
will need to supply the following data for users:

* user id
* user display name
* email address

Note that `user id` is specific to your app. It is recommened that you use
your internal database id or other primary key for the user. The API treats
`user id`s as unique per application.

### Listing Users

    GET /users

Returns:

    {
      count: 2,
      users: ["1", "2"]
    }

### Creating/Updating a User

    PUT /users/1
    {
      name: "Amir",
      email: "amir@example.com"
    }

### Getting a User

    GET /users/1

Returns:

    {
      name: "Amir",
      email: "amir@example.com"
    }

### Removing a User

    DELETE /users/1

## Topics

A topic is a list of messages identified by a key. The key can be any
string, and is often an id or a URL. Namespacing topic keys is up to
the application.

### Creating/Modifying a Topic

You don't explicitly need to create a topic, but creating one allows you
to customize the defaults:

    PUT /topics/foo
    {
        email_notifications: true,
        email_replies: true,
        save_deleted_messages: false
    }

The above will enable email notifications and replies. If you try to post
a message into this topic and a `user id` doesn't have an email address
associated with it, the request will fail.

### Listing Topics

    GET /topics

Returns:

    {
      count: 1,
      topics: [
        {id: "foo", create_date: "...", update_date: "...", participants: 2}
      ]
    }

### Checking if a Topic Exists

    HEAD /topics/foo

## Messages

Messages can be posted into any topic and topics don't need to be created
ahead of time.

### Listing Messages in a Topic

    GET /topics/foo

Returns:

    {
      create_date: "...",
      update_date: "...",
      participants: 2,
      count: 2,
      messages: [
        {id: "m1", from: 1, date: "...", text: "test message."},
        {id: "m2", from: 2, date: "...", text: "worked!", in_reply_to: "m1"}
      ]
    }

If the `deleted=true` query parameter is used and if the topic has been
configured to save deleted messages, they will appear in the results. Any
deleted message will have a `deleted` key set to the date of deletion.
Normal messages will have no `deleted` key.

### Listing Message Details

    GET /topics/foo/m1

Returns:

    {
      from: 1,
      date: "...",
      text: "test message."
    }

### Posting a Message

If the specified topic id doesn't exist, a new one will be created with
defaults taken from your account.

    POST /topics/foo
    {
      from: 1,
      text: "why was my message removed?"
    }

Note that the message id will be generated by the API. If you want to
specify your own message id, use the PUT verb:

    PUT /topics/foo/myId1
    {
      from: 1,
      text: "why was my message removed?"
    }

In this case, you will be responsible for ensuring uniqueness of your ids
since a PUT to an existing message will overwrite it.

### Checking if a Message Exists

    HEAD /topics/foo/m1

### Removing a Message

    DELETE /topics/foo/m1

## Notifications

To know when someone posts a new message, for example, it's possible to
poll the API for changes. Although this is allowed, it's not recommended
since it is wasteful, inefficient, and subject to rate limits.

Each notification follows the same format:

    {
      seq: "<unique sequence number>",
      type: "<type of notification>",
      action: "<create or remove>",
      id: "<id of type>"
    }

The notification may also contain other fields, depending on the value
of the `type` field.

### WebSockets

Connect to `wss://api.unnamed/` and send the following message:

    {
        auth: "<api key>"
    }

On successful authentication, the API will return:

    {
        auth: "success"
    }

You can now subscribe to events:

    {
      subscribe: [
        {type: "message", topic: "<topic id>", actions: ["<action>", ...]},
      ]
    }

To subscribe to all events, instead of sending an array, send a true
boolean value.

On success, the API will return:

    {
      subscribe: "success"
    }

After this, you will receive events as individual messages.

To unsubscribe, send:

    {
      unsubscribe: [
        {type: "message", topic: "<topic id>", actions: ["<action>", ...]},
      ]
    }

To unsubscribe from all events, send a true boolean value instead of an
array.

To disconnect, unsubscribe from all events and close the connection.

### Push Notifications (Web Hooks)

With push notifications, the API will perform a POST request to a URL
of your choosing anytime there are new messages. Notifications are batched,
so that each POST request may contain multiple notifications. In the event
that your server is down or returns a non-200 status code, the API will
keep retrying over the next 24 hours. After that time, pending
notifications will be discarded.

The API will make a signed POST request:

    POST /your/uri HTTP/1.1
    Host: example.com
    X-Unnamed-Api-Signature: <sha1 signature of POST body>

    [
      {seq: "1001", type: "topic", action: "create", id: "foo"},
      {seq: "1002", type: "message", action: "create", id: "m1", from: "1"}
    ]

You are expected to return a 200 status code. If you return a response
body, it will be ignored.

### Continuous Updates

If push notifications via web hooks aren't suitable for your application,
then continuous updates (real-time push) is a great alternative. However,
not all HTTP client libraries support it.

With real-time push, your application makes a GET request to the API to
wait for events. If there are no pending events, the API will send a
single newline character (`\n`) to keep the connection open. To adjust
the default of 10 seconds, use the `heartbeat` query string parameter.

A special `/feed` URI prefix is used to "push-enable" any of the
supported API endpoints.

To get notified about topics:

    GET /feed/topics?heartbeat=30

To get all events:

    GET /feed?heartbeat=15

In the event that you get disconnected, make not of the last event's
`since` value and send it on the next request:

    GET /feed?since=1001&heartbeat=15

Omitting the `since` will cause all historical events to be delivered
again. However, the API currently will only return the past 10,000
recent events

## HTTP Response Codes

The API will emit standard HTTP response codes in REST fashion.

## REST Fallback for Legacy Clients

To accommodate older HTTP clients that are only able to make GET and POST
requests, include either an `X-HTTP-Method-Override` HTTP header or a
`_method` query string parameter specifying the actual method to be used.

In the latter case, a DELETE request would look like:

    GET /topics/foo/m1?_method=DELETE

And a PUT request would look like:

    POST /topics/foo?_method=PUT
    {
      ...
    }
